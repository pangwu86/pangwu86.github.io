{"posts":[{"title":"重新搭建个人博客","text":"上次搭建博客还是 14 年初，坚持写到了 17 年底，后来因为记不得的原因就停下了，然而这一停就是 5 年。 后来想拾起来继续写，但发现之前用的图床挂了，又要域名又要备案的，就放弃了。 直到去年底，发现还是有一个能自己撒欢的地方比较好，于是又重燃了写博客的动力，才有了今天又一次搭建博客。 技术选型梳理了一下个人需求，主要是以下几点： 支持 Markdown 格式。 图片本地一份图床一份，Markdown 中引用床图地址。 生成静态文件，随便放个服务器就行。 支持各种插件或个人修改源码，方便后续定制。 调研了一圈，最后发现还是 Hexo 满足要求，那就开始搞吧。 搭建步骤本地搭建先搭建 Node 环境，然后全局安装 Hexo，接着找个自己喜欢的主题，新建一个文章，本地跑起来看看效果即可。 主题这次没有选 NexT, 而是选择了 icarus, 感觉新主题更顺眼一些，内置的 widget 也更多些。 主要也是换换风格，就跟过年穿新衣服一样，更有新鲜感，让人有种重新开始的感觉。 服务器搭建前期可以直接放到 GitHub Pages 来托管页面，免费还自带了 Https，等真有必要了再买个服务器搞个 Nginx 跑一下就好。 域名和备案国内云服务现在都要求你买它家的服务器后再备案，所以既然选了国内云服务商那就做全套了。 好在备案流程比原来方便多了，直接通过 app 拍照上传资料，不再需要之前的买幕布邮寄之类的了，省时省力呀。 不过新的政策多了一个公安联网备案，好在流程也不复杂，半小时内填填表格上传照片就行了，剩下的就是等 n 个工作日了。 免费图床本来选用七牛云，因为有 10G 免费流量，不过后来发现免费的只有 http 流量，https 还是要收费。并且想用七牛必须要有已备案的域名，也是个门槛。 后来发现了 GitHub + jsDelivr 这个大杀器组合。不但可以白嫖 GitHub 大空间，还有 jsDelivr 的免费 cdn 加速，并且支持 https，上传图片使用 PicGo 这样的工具，整个链条简直是完美。 优化改进图片的引用与备份上次写博客时七牛云的图片因为没有备案域名访问不了了，有点蛋疼。所以这次对于图片的保存和引用额外上心。 最终方案是图片本地一份，图床一份。文件路径与名称完全一致，这样将来如果图床有问题了，随时可以切换到本地或其他图床。不过文章如果是分享到其他平台的话，引用图床的图片可能就挂了，这个还没想到解决方案，不过先保证自己的博客没问题就行了。 icarus 定制修改主要是针对一些页面布局与配置的调整。 更新：widget 控件的 sticky 属性支持按照页面类型设置 更新：社交链接支持了图片格式 新增：page 为一种页面属性 更新：底部 footer 支持备案信息 还有一些后续优化等有时间单独记录下，有需要可以直接用这个修改后的 胖五定制版 Icarus。","link":"/posts/16de371/"},{"title":"日亚海淘原版乐谱攻略","text":"五一假期前尝试从日本亚马逊海淘了几本钢琴谱回来，俩周不到就顺利通关收到了。这里记录一下整个过程，为有同样买谱需求的朋友们提供个参考。 前期准备先给列表再说原因： 翻墙工具，用来上日亚。 一张 VISA 或 MasterCard 信用卡，用来支付。 首先日亚最近封锁了中国大陆 IP，无法直接进行访问了，而乐谱类的商品又不在日亚海外购的范围内，所以翻墙上日亚成了必备条件。 再就是支付，日亚不支持使用银联卡，一张双币卡或全币卡就成了必需品。双币卡一般是美元加人民币，如果是在日亚下单，会使用美元下单，然后银行自动根据当天汇率转换为日元进行支付，这其中美元转日元是有一定的手续费的。所以如果长期海淘还是推荐办一张全币卡，可以直接使用当地的货币进行支付，少了一步转换的费用。 这里顺道推荐一下 招行的全币卡，支持多国货币结算且没有年费，非常适合海淘。 寻找转运公司没有海外购的直邮，就只能把商品的下单送到当地的国内地址，然后再让人帮忙把东西寄回国内，这个就是转运公司做的事情。 网上能搜到的转运公司很多，有做美亚的，有做日亚的，每家都有自己的邮寄路线，不同线路对邮寄商品有些限制，也有时效的问题，比如海运便宜适合寄大件但邮寄时间长一般要 45-60 天，空运很快 1-2 周但运费贵也有重量上限。不同转运公司价格收取也有一些差异，他们一般是根据当地收费标准x当天汇率来收取费用，不过他们的汇率比银行要高一些。不同家也有一些额外的服务提供，比如几个箱子合箱去重，开箱拍照等，有些收费有些免费，这个也是按需选择即可。 还有特别重要的一点是注意自己的商品是否在海关禁运的列表内，比如一些18禁或涉及政治的书籍就属于禁运品，禁运轻则退运，重则没收，所以下单前最好先咨询一下转运公司的客服是否可以邮寄，有没有什么限制。同时要明白商品清关时有可能被收取关税，不同类型商品关税不一样，具体可查看 中华人民共和国进境物品归类及完税表，留出预算做好被税的心理预期。 总之，找转运公司要多多比较，网上搜搜口碑较好的，经营时间长的，甚至可以先购买一个小件试着运一单试错一下。 总结一下流程： 找到几家转运公司作为备选 询问购买的商品是否可以转运，有无限制 估算购买商品的重量，权衡邮费和时效，选择合适的邮寄路线，有些保税线路也是不错的选择。 注册转运公司账户，记下他们给出的转运邮寄地址（日本国内地址） 去日亚下单可以翻墙上日亚，有了全币卡，也有了转运邮寄地址，就可以在日亚下单了。 日亚现在提供了官方的翻译服务，可以不用摸黑（看不懂日文┭┮﹏┭┮）下单了。登上 日亚首页，先把页面拉到最下面，中间部分就是语言选择下拉框，点击选择简体中文就好了。 切换好中文后就方便多了，接着就是注册日亚账户和挑选商品。 注册账户没啥可说的，按照提示一步步来即可，如果真的搞不定可以看看转运网站上的教程，一般都会有日本相关购物网站的注册流程说明，或者去问问转运公司的客服她们也会帮你完成的。 挑选商品时有两个特别注意的地方： 库存与发货时间 有些库存不足的要很长时间才能发货，如果你有其他商品一起海淘的话可能会跟其他商品无法一起及时寄回来，如果放在转运公司的商品等着这个一起寄回，则要考虑已经寄到转运公司的商品的存储费用，一般是 30 天免费超时收费，所以尽量选择可以马上发货的下单。 卖家是否为日亚官方 如无必要，千万不要选择第三方。就跟京东一样，官方的邮寄和售后更有保障，第三方就稂莠不齐了。在选择商品时，注意右边下面写的卖家是不是 Amazon.co.jp ，是的话就可以安心加入购物车了。 接着就是确认购物车，开始进行支付结算。收货地址选择转运公司提供的地址，付款方式选择自己的全币卡。最后支付环节还有一点需要注意就是选择本地货币下单。亚马逊现在提供了货币转换服务，可以方便那些没有全币卡的用户使用其他货币来进行支付，不过这也就意味你要额外支付一遍货币转换费用。因为我们已经有了全币卡，所以支付的时候一定要选择本地货币来进行支付，美亚就选美元，日亚就选日元，以此类推。 转运货物下单以后就可以等着日亚的邮件通知了，在日亚发货后订单会多一个运单号（不是订单编号），记下这个单号（一般是以 DA 开头，例如 DA0121981899）然后去转运公司的网站提交入库单。这个操作主要就是通知转运公司收货，方便后面进行转运。 等转运公司那边收货后，就可以提交转运发货了，如果有多个订单就等一起收到后再发货。发货操作就是选择转运路线，填写商品信息，然后支付费用，剩下的就是耐心等待收货并经常查看一下邮寄状态。 在自己填写商品信息，一般会要求填写商品的英文/日文/中文名称，这里推荐大家直接去美亚找相同的商品，一般就能找到对应的英文名称，去淘宝搜商品基本能找到对应的中文名称。 在商品寄到中国后会在海关进行清关，这个在时间上不固定，短的半天长的几周都有可能。还有不同海关检查力度不一样，有的是必查有的是抽查，商品税费不超过 50 不收取，超过了但没有走保税路线的话就拼人品了。万一真的被税了，也不用太担心，一般是自己去当地邮政部门自行缴费就行了。 最后总结以上就是整个转运的全过程了，其实亲自操作一遍并熟悉流程后还是挺简单的。当然不想自己费劲也可以去淘宝找那些代购帮你来下单，不过也少了一份全称参与的乐趣。 最后祝大家海淘顺利，购物愉快，永不被税。","link":"/posts/860259780/"},{"title":"Git 常用命令清单","text":"Git 命令还真不少，列一下方便回顾与查找。 创建库12345678# 当前目录初始化为git库git init# 新建一个目录，初始化为git库git init [project-name]# 下载一个git库git clone [url] 配置 .gitconfig Git 配置文件，可以在用户主目录下（全局），也可以在仓库目录下 .gitignore 过滤配置文件，告诉 Git 哪些文件不需要加入到版本管理中 设置的主要命令为 git config，加上参数 --global 则表示为全局配置，不使用则是修改当前仓库配置。 12345678910# 显示当前git配置git config --list# 编辑git配置文件，使用默认编辑器打开git config -e [--global]# 设置用户名和邮箱git config [--global] user.name &quot;your name&quot;git config [--global] user.email &quot;your email&quot; 增加删除文件123456789101112# 添加指定文件到暂存区git add [file1] [file2]# 添加指定目录到暂存区git add [dir]# 添加当前目录的所有文件到暂存区git add .# 删除工作区文件，并将删除放入暂存区# PS:只能删除已经在版本库中的文件git rm [file1] [file2] 提交文件1234567891011# 提交暂存区到仓库, 记录提交日志git commit -m [message]# 提交工作区上次commit的变化到仓库git commit -a# 整合-a和-m，一般的常用操作git commit -am [message]# 使用一次新的commit，合并上一次提交（反复修改）git commit --amend -m [message] 撤销修改1234567891011# 撤销工作区某些文件的修改git checkout -- [file1] [file2]# 撤销工作区所有文件的修改git checkout -- .# 丢弃已经进入暂存区的修改, 回复到 HEAD 状态git reset HEAD [file]# 重置暂存区与工作区，与上一次commit保持一致git reset -hard 查看信息1234567891011121314151617181920212223242526272829303132333435# 显示当前变更的文件git status# 显示当前版本记录, -n为显示n行git log [-n]# 显示commit历史，以及对应发生变化的文件git log --stat# 查看某个文件的版本历史git log --follow [file]# 查看每一次diff内容git log -p# 查看某个文件的每一次diff内容git log -p [file]# 查看当前所有的改动git diff# 查看当前某个文件的改动git diff [file1]# 查看工作区与最新commit的差异git diff HEAD# 查看某次提交详细内容git show [commit]# 查看最近的几次提交git reflog# 显示所有提交过的用户，按提交次数排序git shortlog -sn 分支在 git branch 的输出内容中，有一个分支，前面带有 * 号，这标识我们当前所在的分支 123456789101112131415161718192021222324# 列出所有分支git branch# 列出所有远程分支git branch -r# 列出所有本地分支和远程分支git branch -a# 新建一个分支git branch [branch-name]# 删除分支git branch -d [branch-name]# 切换到指定分支git checkout [branch-name]# 合并指定分支到当前分支git merge [branch-name]# 建立现有分支与远程分支关系git branch --set-upstream [branch] [remote-branch] 标签1234567891011121314151617# 列出标签git tag# 新建标签git tag [tag]# 删除本地标签git tag -d [tag]# 查看tag信息git show [tag]# 提交标签git push [remote] [tag]# 提交所有标签git push [remote] --tags 远程同步1234567891011121314151617181920# 下载远程仓库所有变动git fetch [remote]# 显示所有远程仓库git remote -v# 显示某个远程仓库信息git remote show [remote]# 增加一个远程仓库并命名git remote add [short-name] [url]# 取回仓库的变化，与本地分支合并git pull [remote] [branch]# 上传本地分支到远程仓库git push [remote] [branch]# 推送所有分支到远程仓库git push [remote] --all git fetch 和 git pull 之间的区别： git fetch 是仅仅获取远程仓库的更新内容，并不会自动做合并。 git pull 在获取远程仓库的内容后，会自动做合并，可以看成 git fetch 之后 git merge。 参考资料 https://segmentfault.com/a/1190000039147662 https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html https://gist.github.com/guweigang/9848271#file-git_toturial https://segmentfault.com/a/1190000011673663","link":"/posts/3646253715/"},{"title":"如何选择一台电钢琴","text":"女儿学琴的地方是可以免费练琴的，不过赶上别人上课的话就没有空的琴房了，所以家里备一台练习用的琴成了刚需。正好赶在春节前买了一台，用到现在感觉还不错，这里就分享一下选琴中做的一些功课。 电钢与机刚电钢，也就是数码钢琴，按下琴键后，通过内置软件计算最终通过音响发出声音。 机钢，也就是机械钢琴，按下琴键后，通过一系列机械结构控制弦槌击弦发音。 作为乐器两者最大的区别就是发声原理不同，电钢发出的声音都是提前在机钢上录制好的，按下琴键发出对应声音。可以说电钢就是在无限模拟机钢，而且价格越高模拟成分越多，一些高端款甚至采用会采用和机钢一样的结构来模拟手感。 先说优点： 价格便宜 机钢基本二手也要 1W 起步，好的更是上不封顶。电钢的话 1W 左右已经可以买到大牌的高端款了 占地空间少 机钢哪怕是立式钢琴也要 200 斤以上，考虑到房子大小与搬动的问题，电钢的这方面完胜。 维护费用低 机钢是需要保养的，需要注意使用环境的温度湿度，还要定期调音。电钢作为一种电器，基本可以算免维护了。 不扰邻 作为没有住独栋别墅的普通人来说，练琴真的是一件影响邻里关系的事情。电钢可以调节音响音量，也可以带着耳机练习，就可以避免打扰别人了。 MIDI与蓝牙 这个可以说是电子设备的强项了，想要录段音频或用个练琴辅助软件啥的都很方便。 音色丰富 除了钢琴一般还有其他电子乐器的声音，甚至外接软音源的话想要啥声音有啥声音，比如用苹果的库乐队，直接吉他架子鼓都能用钢琴弹了。 再谈缺点： 手感 这个因为成本与按键结构问题，越是低端的电钢问题越多，那种塑料感与力度反馈都与机钢不同。高端的电钢这点有改进，但也是尽可能的模拟机钢手感。 音色 这里主要是因为发音原理不同，少了那种琴弦震动与共鸣特有的感觉，少一分灵性在里面。 总之从练琴角度来说，大部分老师都是推荐机钢来练琴的，但从现实角度来说，不论是价格，后期维护还是使用方便程度上，电钢性价比更高一些。 品牌与价格 常见的大牌就是雅马哈（YAMAHA），卡瓦依（KAWAI），卡西欧（CASIO），罗兰（Rolan），科音（KORG）这些了，针对使用场景的不同，电刚也分成了 便携式电钢，家用电钢，舞台电钢 几个大类。 一般来说练琴就选择便携式或家用电钢，舞台电钢更多针对的是编曲，演出环境而存在的，功能上会有更多的效果器，控制器之类的东西。 按价格区间来分： 1000-3000 算是低端，不推荐。因为用料键盘手感都很一般，这个档位也基本都是入门便携式。 3000-6000 算是中端，一般推荐。这个档位基本是家用钢琴了，一般会有那种立式钢琴架子，下面带着 3 个踏板，整体样子也更接近立式机钢。这里的键盘的键床一般会比低端的高一个档期，手感更好，功能上也多一些。 6000-10000 算是中高端，推荐。其实比中端多花一点点就能买到高端的入门款了，这里各家基本就有一些拿得出手的高级特别往琴里塞了，不管是键床还是音响，还有键盘材料都明显好很多，使用体验也更加接近机钢。 10000+ 高端，推荐。这里就没啥可说的了，有钱买最新的最好的就是了，甚至还有混合钢琴这种神奇的东西存在。 这里就不推荐具体型号了，想明白自己到底需要一台琴做什么，要手感？要音色多？要能蓝牙连接设备？把各种需求列出来，然后按照预算在大牌子里对应区间去找就行了，基本没啥问题。再就是通过知乎，B 站等找找测评，多看看多比较下。 购买渠道 线下琴行 线上电商 论坛团购 咸鱼 琴行一般来说都相对贵一些，但本地琴行买的话 售后方便一些。 线上电商的话，一般也是琴行对接发货，不过有些是总代也会是外地发货，价格跟琴行差不多，搞活动时会略便宜些。 论坛的话键盘中国有团购，很多年了口碑还不错。 咸鱼可以说是买琴最便宜的地方了，很多琴贩子不知道从哪里渠道弄的，确实是省了中间商差距，一般也就是琴行价格的 3/4 左右，但售后是个问题 这个需要提前有个心理准备。 总之做好预算，货比三家，在能接受的范围内买最贵的，还是一分钱一分货的道理。","link":"/posts/fedd2d3d/"},{"title":"2021 个人投资复盘(1-2季度)","text":"上半年各种瞎操作交了不少学费，希望下半年收益能好些。 上半年成绩单总的来说把年前挣的钱都亏进去了，而且还亏了不少。 总结经验教训操作过程： 年前行情大好，盈利不少。 年后开始走低，但没有及时止盈，一直觉得还会上扬。 等反应过来真的行情不行了，抛晚了，损失了大部分盈利。 新买了几只历史行情不错的，但没有拿住。 不但没有拿出，有的还在最低点割肉抛掉了。 想着买点美股港股对冲一下，结果国外行情反而不如国内，损失惨重。 4月份开始几个题材股又开始走强。 吃药，喝酒，开车，目前这三个是涨势比较强的。 教训总结： 国外的几个因为汇率和开盘时间，导致买卖都是T+2，赌运气一般的操作。 白酒还是A股的中流砥柱，厉害。 新能源还是很好的题材，中国这方面全球领先，政策支持也好。 医药长期看好，7普数据人口老龄化严重，外加疫情反复，药品需求更多。 看好的行道不要害怕，割肉跑路是大忌，此时更应该买入。 不确定行情但又担心错过时，可以少量买卖。 不要想着一次性挣多少，只要保证少赔多挣就行。 少操作，一周仅操作一次。 下半年目标目标： 国外的几个不抛，等待行情恢复，回本再抛。 继续关注吃药，喝酒，开车三个题材，逢低买入。 尝试债券投资，5w本金。","link":"/posts/2488034638/"},{"title":"Vuetify 与 Vue-i18n 整合踩坑指南","text":"项目中使用了 Vuetify 这个 UI 库，现在要加上多国语言功能，踩了几个坑记录下。 使用Vuetify内置i18nVuetify 的国际化文档链接 初始化1234567891011121314151617181920// 引用vue,vuetifyimport Vue from 'vue'import Vuetify from 'vuetify/lib'Vue.use(Vuetify)// 选择需要的语言// 例如：简体中文 + 日文import zhHans from 'vuetify/es5/locale/zh-Hans'import ja from 'vuetify/es5/locale/ja'// 设置lang相关参数const vuetify = new Vuetify({ lang: { current: 'zhHans', locales: { zhHans, ja }, },})const app = new Vue({ vuetify}).$mount(&quot;#app&quot;); 使用 t 函数1&lt;div class=&quot;my-component&quot;&gt;{{ $vuetify.lang.t(&quot;$vuetify.hello&quot;) }}&lt;/div&gt; 切换语言12// 触发切换时this.$vuetify.lang.current = &quot;zhHans&quot; 使用 Vuetify 整合 Vue-i18nVue-i18n 的官方文档链接 Vuetify 内置国际化功能比较简陋，官方也推荐使用整合的方式，后续添加自定义的国际化文本也更方便些。 初始化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 引用vue,vuetify,vue-i18nimport Vue from 'vue'import Vuetify from 'vuetify/lib'import VueI18n from 'vue-i18n'Vue.use(Vuetify)Vue.use(VueI18n)// 选择需要的语言// 例如：简体中文 + 日文import zhHans from 'vuetify/es5/locale/zh-Hans'import ja from 'vuetify/es5/locale/ja'// 整合自定义的信息// 如果使用 $vuetify.lang.t 则需要把内容定义在 $vuetify 命名空间下const zhHansUser = { ...zhHans, hello: &quot;你好&quot;, $vuetify: { hello: &quot;你好&quot;, }}const jaUser = { ...ja, hello: &quot;こんにちは&quot;, $vuetify: { hello: &quot;こんにちは&quot;, }}// 创建 VueI18n 实例const i18n = new VueI18n({ locale: &quot;zhHans&quot;, messages: { zhHans: zhHansUser, ja: jaUser }});// Vue-i18n的t方法替换Vuetify的默认实现const vuetify = new Vuetify({ lang: { t: (key, ...params) =&gt; i18n.t(key, params), },})const app = new Vue({ vuetify, i18n}).$mount(&quot;#app&quot;); 使用 t 函数123456&lt;!-- 使用 $t 没有规则限制 --&gt;&lt;div class=&quot;my-component&quot;&gt;{{ $t(&quot;hello&quot;) }}&lt;/div&gt; &lt;div class=&quot;my-component&quot;&gt;{{ $t(&quot;$vuetify.hello&quot;) }}&lt;/div&gt; &lt;!-- 使用 $vuetify.lang.t 只能获取 $vuetify 命名空间下的内容 --&gt;&lt;div class=&quot;my-component&quot;&gt;{{ $vuetify.lang.t(&quot;$vuetify.hello&quot;) }}&lt;/div&gt; 切换语言12// 触发切换时this.$i18n.locale = &quot;zhHans&quot; 总结 Vuetify 自带了一套国际化配置，但实现的 t 函数的功能相对简陋，所以实际项目中更适合加入 Vue-i18n 整合使用。 Vuetify 国际化文本都放在 $vuetify 这个命名空间下。 整合 Vue-i18n后，实际上就是使用 Vue-i18n 来实现国际化，把 Vuetify 的文本导入并且托管了 Vuetify 的 t 函数。","link":"/posts/1360575077/"},{"title":"Oracle 云安装宝塔 Linux 面板","text":"今天成功白嫖到了 Oracle 永久免费云，尝试安装下宝塔 Linux 面板。 如何注册 Oracle 云就不写了，直接参考别人写好的 注册攻略 吧，主要是需要一张外币卡（VISA 或 MasterCard）做付费校验（并不会真的扣钱），其他的没啥难度了。 创建实例除了镜像需要修改，其他按照默认配置即可，记得看一下选中的项目带着符合始终免费条件这个提示。 因为要安装宝塔面板，在选择镜像时取消默认的 Oracle Linux，按照宝塔文档给出的兼容性列表改成 CentOS/Debian/Ubuntu 其中一个。按照自己惯用的选就行，这里是选择了 Ubuntu 20.04 镜像，后面的操作命令也是基于该镜像。 添加入站规则创建好实例后，点击屏幕右边的子网：xxxx-xxx-xxx, 进入安全列表列中的项目，然后在入站规则上，点击添加添加入站规则按钮。在弹出窗口后按照下面的信息填充即可。 源CIDR 0.0.0.0/0 – 所有协议 开放所有端口现在可以 ssh 远程登录上服务器了，登入后输入以下命令： 12345678910111213141516# 切换root用户sudo -i# 安装必备软件apt-get update -yapt-get install wget curl -y# 开放所有端口iptables -P INPUT ACCEPTiptables -P FORWARD ACCEPTiptables -P OUTPUT ACCEPTiptables -F# 清理并重启apt-get purge netfilter-persistentreboot 安装宝塔 Linux重启完成后再次 ssh 登录上服务器，输入下面的命令耐心等待安装结束即可。 1wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh 登录宝塔面板如果万一不小心没看上面的信息就清屏了，可以执行下面命令，会再打印出相同内容。 12# 显示宝塔面板登陆地址与用户，密码信息sudo /etc/init.d/bt default 登录后记得先修改下登录入口和安全相关配置，然后就可以安装各种软件来随便折腾了。","link":"/posts/2992442120/"},{"title":"如何发布一个 NPM 包","text":"起因是引用了一个 npm 包，发现 bug 后进行了修改并提交了 pull request。等了 20 多天那边一直不上线合并，只能自己把 fork 下来的库单独发布一下了。 下面将简要讲解一下从零开始创建，发布并使用自己的库的过程。 新建一个库 OR fork 一个库 创建新库 创建目录，然后使用命令 npm init 进行初始化，按照提示一路填写并回车即可。 fork 别人的库 把别人的库 fork 后下载到本地，然后修改 pakcage.json 中库名，用户名等个人信息即可。 暴露你的库接口如果希望自己的库也能像 npm 中其他的库那样导入，比如 import Vue from 'vue', 一些必要的前期工作还是需要完成的。 在 package.json 中 main 属性要指定好入口文件，一般是 index.js。 在入口文件中，使用 export 暴露你的方法，例如 123// 入口文件 index.jsexport function sayHi() { console.log('hi, 你好'); }export default { sayHi } 项目代码里就可以导入并使用了 123456// 项目文件，导入库并使用import mylib from 'mylib'import { sayHi } from 'mylib'sayHi(); // 打印出 `hi, 你好`mylib.sayHi(); // 打印出 `hi, 你好` 注册 NPM 账号，然后发布 在 npm官网 注册账号。 在命令行下执行 npm login，使用刚才注册的账户信息进行登录。 在命令行下进入项目根目录，执行 npm public，发布成功后会收到一份 npm官网 发送的通知邮件。 在 npm官网 搜索包名应该就能看到了。 更新库内容如果更改了包的内容需要更新版本再次发布。 修改 package.json 中 version 参数，将版本号增大。 再次执行发布命令 npm publish。 没有更新版本号发布的话，会报错。 常见错误处理Error 403：Forbidden说明你起的包名在 npm 的公开库上已经存在了，所以要么改名，要么给包名加一下前缀，比如把 mylib 改成 @xx/mylib。 Error 402：Payment Required如果包名称带有 @xx 前缀，默认被当做私有库进行发布。而私有库是需要额外收费的，所以在发布这种库时需要指定其为公开库，不过仅仅是第一次发布需要，后续更新再发布可以不用加参数了。 12# 第一次发布带有 @xx 前缀的库npm publish --access public 其他注意事项如果是 fork 别人的库进行修改的，特别需要注意下原本库使用的 开源许可 是否允许这种二创的行为。 关于各种开源许可证的差异，可以参考以下几篇文章，都写的挺清楚的。 阮一峰的网络日志 &gt; 如何选择开源许可证？ liferay &gt; 各种License介绍 懒得看文章的，直接参考下面的图吧。","link":"/posts/2093845957/"},{"title":"Linux 错误『&#x2F;bin&#x2F;bash^M: bad interpreter』解决方案","text":"因为自己经常需要在 Windows 和 macOS 两个平台切换工作，所以遇到了多次跨平台脚本报错的情况，标题中的就是最常见的一个。 错误原因把在 Windows 环境下编写的 shell 脚本放到 Linux 或 macOS 环境下执行，就有很大概率出现该错误。原因是 Windows 下的文件是 dos 格式，每一行结尾以 \\r\\n 来标识，而 Linux 下的文件是 unix 格式，每一行结尾以 \\n 来标识。使用 Vim 打开文件，执行 :set ff, 便可以看到文件格式是什么。 解决方案使用 dos2unix 命令。12345# macOS 使用 brew 安装 dos2unixbrew install dos2unix# 修改文件格式dos2unix [filename] 使用 Vim 直接修改 fileformat。123456# 打开文件vim [filename]# 修改文件格式并保存:set ff=unix:wq","link":"/posts/1268822334/"},{"title":"IoT 基础知识入门","text":"最近开始接触硬件了，需要了解下 IoT 相关的知识，这里记录一下。 什么是 IoT物联网 Internet of Things （简称 IoT ），通过各种传感器，实时采集任何需要监控，连接，互动的物体或过程，通过各类可能的网络接入，实现物与物，物与人的连接。 物联网现实了世界数字化，应用范围十分广泛。物联网可拉近分散的资料，统整物与物的数字信息。 物联网技术结构架构一般分成三层或四层，由底层至上依次为： 感知设备层，用于收集信息。 网络连接层，用于传递信息。 平台工具层，用于整合信息，提供基础服务。 应用服务层，按照某些业务需求使用数据进行软件应用。 物联网应用场景根据不同的使用群体，大概分成一下几类： 消费者应用。场景包括共享单车，智能快递柜，智能穿戴设备，无人机，智能家电等。 工业应用。场景包括机器人，医疗设备，软件定义生产。 农业应用。收集温度，降水，湿度，风速，病虫害和土壤成分等数据，加以分析和运用。 商业应用。医疗保健，交通运输等。 知识点名词解释IC集成电路（integrated circuit，缩写作 IC），或称微电路（microcircuit）、微芯片（microchip）、芯片（chip），在电子学中是一种将电路（主要包括半导体设备，也包括被动组件等）集中制造在半导体晶圆表面上的小型化方式。 当今半导体工业大多数应用的是基于硅的集成电路。 MCU单片机，全称单片微型计算机（single-chip microcomputer），也称微控制单元（Microcontroller Unit，即 MCU），是把中央处理器，存储器（程序和数据），定时/计数器，各种输入输出接口都集成在一块集成电路芯片上的微型计算机。 与通用型的个人电脑相比，单片机更强调自供应（不用外接硬件）和节约成本，它一般体积较小，可以放在仪器内部。 现在的单片机绝大多数都是基于冯·诺伊曼结构的，这种结构清楚地定义了嵌入式系统所必需的四个基本部分： 中央处理器核心 程序存储器，数据存储器 定时/计时器 输入/输出端口 根据总线或资料寄存器的宽度，单片机分为 4 位，8 位，16 位和 32位单片机。 4 位单片机多用于冰箱，洗衣机，微波炉等家电控制器。 8 位单片机多用于电表，电动玩具，传真机，键盘，USB 等。 16 位单片机多用于行动电话，数字相机等。 8 位、16 位单片机主要用于一般的控制领域，一般不使用操作系统。 32 位单片机多用于网络操作，多媒体操作等复杂处理的场合，一般需要嵌入式操作系统。 SoC单片系统（System on a Chip，缩写：SoC），直译是“芯片级系统”，通常简称“片上系统”。 SoC更强调的是一个整体，在集成电路领域，给它的定义为：由多个具有特定功能的集成电路组合在一个芯片上形成的系统或产品，其中包含完整的硬件系统及其承载的嵌入式软件。 BSP板级支持包（board support package，简称 BSP）是构建嵌入式操作系统所需的引导程序(Bootload)、内核(Kernel)、根文件系统(Rootfs)和工具链(Toolchain) 提供完整的软件资源包。 BSP主要功能为屏蔽硬件，提供操作系统及硬件驱动，具体功能包括： 单板硬件初始化，主要是CPU的初始化，为整个软件系统提供底层硬件支持 为操作系统提供设备驱动程序和系统中断服务程序 定制操作系统的功能，为软件系统提供一个实时多任务的运行环境 初始化操作系统，为操作系统的正常运行做好准备。 UART通用异步收发传输器（Universal Asynchronous Receiver/Transmitter)，通常称作UART，是一种通用串行数据总线，用于异步通信。该总线双向通信，可以实现全双工传输和接收。在嵌入式设计中，UART用于主机与辅助设备通信，如汽车音响与外接AP之间的通信。 UART作为异步串口通信协议的一种，工作原理是将传输数据的每个字符一位接一位地传输。 SPISPI是串行外设接口（Serial Peripheral Interface）的缩写，是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，正是出于这种简单易用的特性，越来越多的芯片集成了这种通信协议。 I2CI2C一般指I2C总线。I2C总线是由 Philips 公司开发的一种简单、双向二线制同步串行总线。它只需要两根线即可在连接于总线上的器件之间传送信息。 ADC模拟数字转换器（Analog to Digital Converter）即 A/D 转换器，简称 ADC。A/D 转换的作用是将时间连续、幅值也连续的模拟信号转换为时间离散、幅值也离散的数字信号。 GPIOGPIO（General-purpose input/output），通用型之输入输出的简称，其接脚可以供使用者由程控自由使用，PIN 脚依现实考量可作为通用输入（GPI）或通用输出（GPO）或通用输入与输出（GPIO）。 既然一个引脚可以用于输入、输出或其他特殊功能，那么一定有寄存器用来选择这些功能。 简单说，GPIO 就是芯片上的一根干啥都行的引脚。 SDIOSDIO（Secure Digital Input and Output）中文名称：安全数字输入输出，定义了一种外设接口。 一般应用是通过 SDIO 硬件接口读写 TF 卡。 PWM脉冲宽度调制（Pulse width modulation，PWM），控制方式就是对逆变电路开关器件的通断进行控制，使输出端得到一系列幅值相等但宽度不一致的脉冲，用这些脉冲来代替正弦波或所需要的波形 G-sensorG-sensor，也叫做重力传感器/加速度传感器/运动传感器，检测设备是否在运动的。 芯片封装封装形式是指安装半导体集成电路芯片用的外壳。它不仅起着安装、固定、密封、保护芯片及增强电热性能等方面的作用，而且还通过芯片上的接点用导线连接到封装外壳的引脚上，这些引脚又通过印刷电路板上的导线与其他器件相连接，从而实现内部芯片与外部电路的连接 封装发展进程: 结构方面：TO－&gt;DIP－&gt;LCC－&gt;QFP－&gt;BGA －&gt;CSP－&gt;WLP； 材料方面：金属、陶瓷－&gt;陶瓷、塑料－&gt;塑料； 引脚形状：长引线直插－&gt;短引线或无引线贴装－&gt;球状凸点； 装配方式：通孔插装－&gt;表面组装－&gt;直接安装。 常见的封装类型有： DIP封装（Dual In-line Package），双列直插封装，具有两排引脚可插到主板上插槽或焊接到主板上。 BGA封装（Ball Grid Array Package）球栅阵列封装，I/O 引脚多。 QFN封装（Quad Flat No-leads Package）, 无引线四方扁平封装，完全没有任何外延引脚。","link":"/posts/3465478745/"},{"title":"jsDeliver 强制刷新缓存","text":"博客一直在用 jsDelivr 当床图，但有时图片更新频繁，会发现 CDN 的缓存刷新不及时，总是要等很久才能看到新版本图片，这里记录一下强制刷新缓存的方法。 jsDelivr基本使用方式目前 jsDelivr 是一个免费，开源的加速 CDN 公共服务。通过在 Github 中创建一个公开库，我就可以通过 jsDelivr 的服务访问到库中的文件，这也就是使用 jsDelivr 作为床图的原因。 访问文件的链接一般如下： 123456789# 访问最新版https://cdn.jsdelivr.net/gh/${用户名}/${仓库名}/${文件路径}# 访问特定版本号https://cdn.jsdelivr.net/gh/${用户名}/${仓库名}@${发布的版本号}/${文件路径}# 访问特定分支https://cdn.jsdelivr.net/gh/${用户名}/${仓库名}@${分支名称}/${文件路径} jsDelivr 还支持一些特殊操作， 12# 获取目录下的文件列表，给出的目录地址最后加上 / 即可https://cdn.jsdelivr.net/gh/vuejs/docs/ 123# css, js 类型文件支持自动创建 .min 文件# 如果不存在，jsDelivr 将为您生成https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/jquery.min.js jsDelivr如何刷新缓存首先 CDN 缓存同步需要时间是个正常现象，像我们这样改了就要看到刷新结果的属于 ”特殊需求“ 了，但也很常见了。 方法也很简单，只要把想要刷新的文件路径的前缀 cdn 改成 purge 即可，看到一段返回的 json 对象，即表示刷新成功，再访问 cdn 地址就可以看到最新的版本了。 12345678910111213141516171819202122232425262728# 刷新前https://cdn.jsdelivr.net/gh/user/images/my.jpg# 刷新缓存https://purge.jsdelivr.net/gh/user/images/my.jpg# 返回结果{ &quot;id&quot;: &quot;783923723947294&quot;, &quot;status&quot;: &quot;finished&quot;, &quot;timestamp&quot;: &quot;2022-04-17T15:52:23.536Z&quot;, &quot;paths&quot;: { &quot;/gh/user/images/my.jpg&quot;: { &quot;throttled&quot;: false, &quot;providers&quot;: { &quot;fastly&quot;: true, &quot;bunny&quot;: true, &quot;cloudflare&quot;: true, &quot;gcore&quot;: true, &quot;quantil&quot;: true } } }}# 再次访问即可https://cdn.jsdelivr.net/gh/user/images/my.jpg","link":"/posts/3854185796/"},{"title":"Review of Flask, From a Django Developer","text":"Are you familiar with Django, but you want to give Flask a try? or maybe you have no idea what a microframework is?Well today I am going to share my experience with Flask, comparing different aspects of both frameworks, so you can decide which one suits your needs. 你对 Django 很熟悉，但想尝试一下 Flask 吗？ 或者你不知道什么是微框架？今天我将分享我使用 Flask 的经验，比较一下两个框架的不同方面，帮助你决定哪一个符合你的需求。 Why I chose Flask?为什么我选择 Flask？ After working with Django for a few years, I felt the need to explore another popular Python web framework, which is Flask. I always knew that Flask was a microframework (more on that below), but I never built anything with it. So I took the opportunity at work to experiment with a new framework for a certain web application, and my team and I decided to try Flask. So in this post I want to comment my opinions about Flask, after working with Django. 在使用 Django 工作几年之后，我感到有必要探索一下另一个流行的 Python Web 框架，那就是 Flask。我一直知道 Flask 是一个微框架（下面会讲到），但是我从来没有用它建立过任何东西。因此在我有机会在工作中尝试实验新框架创建一个 Web 应用时，我和我的团队决定尝试 Flask。因为在这篇文章里我想评论一下对 Flask 的看法，特别是在使用了 Django 工作之后。 What is Flask?Flask 是什么？ Flask is a micro web framework written in Python. It is classified as a microframework because it does not require particular tools or libraries. It has no database abstraction layer, form validation, or any other components where pre-existing third-party libraries provide common functions. Flask 是一个用 Python 编写的微型 Web 框架。它被分类为微框架式因为它不需要特定的工具或库。它没有数据库抽象层，表单验证或其他现有的第三方提供的常用功能组件。 By contrast, Django is a web framework with a batteries-included philosophy. This means that the common functionality for building web applications should come with the framework instead of as separate libraries, like an ORM, template engine, user authentication and so on. Application Structure应用结构 In your a typical django project with one application, you would have a folder structure as follows: 123456789101112131415django-project├── config│ ├── __init__.py│ ├── asgi.py│ ├── settings.py│ ├── urls.py│ └── wsgi.js└─── app ├── __init.py ├── admin.py ├── apps.py ├── models.py ├── tests.py ├── urls.py └── views.py Whereas in a Flask application, you could start with just one file. 12flask-project└── app.py 12345678910111213# app.pyfrom flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return '&lt;h1&gt;Hello World!&lt;/h1&gt;'@app.route('/user/&lt;name&gt;')def user(name): return '&lt;h1&gt;Hello, {}!&lt;/h1&gt;'.format(name) I remember when I started learning Django, this could be overwhelming, you have to learn why are those files there and adapt yourself to the default structure. In Flask you start with just a file, and you add more files as your project grows, this makes it easy to get started. When you add a file in your Flask app, you now why is there. While in contrast to Flask, it’s easy to get started, but then you have to figure out how to organize your project as it grows, and this can be overwhelming if you don’t have much experience with Flask Templates模版 Flask doesn’t come with a template engine like Django does, but when you pip install flask, this comes with a dependency with Jinja2, which is a template engine, but don’t worry you don’t have to learn a new syntax, since it is similar to Django’s, as you can see in the code below, which is a typical template that you’d create in Django 12345678910{% extends &quot;base.html&quot; %}{% block title %}Home{% endblock %}{% block page_content %}&lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt; &lt;a href=&quot;{{ url_for('index') }}&quot;&gt;Home&lt;a&gt;&lt;/div&gt;{% endblock %} There are differences of course like &lt;a href=&quot;{{ url_for('index') }}&quot;&gt;Home&lt;a&gt;, where in Django that would be &lt;a href=&quot;{% url 'home' %}&quot;&gt;Portada&lt;/a&gt;, honestly, I didn’t find this tedious to learn, since, from my point of view, I think 90% of my knowledge of the Django template is transferable to Jinja2. Forms表单 Being a microframework, Flask relies on WTForms for its forms, that we need to install it, using:pip install flask-wtf.When using Flask-WTF, each web form is represented in the server by a class that inherits from the class FlaskForm. The class defines the list of fields in the form, each represented by an object. Each field object can have one or more validators attached. An example is presented below. 12345678910111213141516171819202122from flask import Flask, render_template# WTFormsfrom flask_wtf import FlaskFormfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequiredapp = Flask(__name__)# against cross-site request forgery (CSRF) attacksapp.config['SECRET_KEY'] = 'my secret'class NameForm(FlaskForm): name = StringField('Enter your name', validators=[DataRequired()]) submit = SubmitField('Submit')@app.route('/', methods=['GET', 'POST'])def index(): name = None form = NameForm() if form.validate_on_submit(): name = form.name.data form.name.data = '' return render_template('index.html', form=form, name=name) 1234567891011{% extends &quot;base.html&quot; %}{% block title %}Hello there!{% endblock %}{% block page_content %}&lt;div class=&quot;&quot;&gt; &lt;h1&gt; Hello, {% if name %}{{ name }} {% else %}there!{% endif %}!&lt;/h1&gt;&lt;/div&gt;{{ wtf.quick_form(form) }}{% endblock %} Personally, I find WTForms more straightforward than Django’s forms. But they have the disadvantage that you have to know how to organize them within the folder structure of your project. So if it’s for a small project, I prefer WTForms. Databases数据库 Authentication身份验证 What I like about Flask我喜欢 Flask 的哪些地方 Control of your project - Don’t fight your framework!对项目的控制 - 不要和框架对着干！ Ecosystem生态 No Magic没有魔法 What I don’t like about Flask我不喜欢 Flask 的哪些地方 Set up your application for the first time第一次设置应用 Conclusion结论","link":"/posts/3737434686/"},{"title":"Node 中下载文件 chunk 拼接注意事项","text":"一个遗留项目中增加下载刷机包功能，但下载下来的文件总是比服务器上大一倍左右，也无法正常使用，问题出在哪里呢？ 本地 Proxy为了方便与线上服务对接测试，本地启动的 server 拦截了所有 http 请求然后转发到指定的服务器。 对于 response 的处理, 将分块发送的数据进行了拼接，最后统一处理。 123456789var handler = function (response) { var reply = &quot;&quot;; response.on(&quot;data&quot;, function (chunk) { reply += chunk; }); response.on(&quot;end&quot;, function () { callback(response.statusCode, response.headers, reply); });}; 因为下载的内容为二进制文件，使用字符串方式的拼接显然是错误的，reply += chunk 的操作等同于 buffer.toString() + buffer.toString(), 把二进制内容当做文本进行拼接，导致了最终内容远大于原始内容。 Chunk 正确拼接经过调查发现有人遇到了类似的错误，解决方案也很简单，对于二进制文件采用 Buffer 来组合分块内容即可。 12345678910111213141516171819202122232425262728var handler = function (response) { var chunks = []; var size = 0; response.on(&quot;data&quot;, function (chunk) { chunks.push(chunk); size += chunk.length; }); response.on(&quot;end&quot;, function () { var data = null; switch (chunks.length) { case 0: data = new Buffer(0); break; case 1: data = chunks[0]; break; default: data = new Buffer(size); for (var i = 0, pos = 0, l = chunks.length; i &lt; l; i++) { var chunk = chunks[i]; chunk.copy(data, pos); pos += chunk.length; } break; } callback(response.statusCode, response.headers, data); });};","link":"/posts/2702290009/"},{"title":"数据大屏制作流程","text":"很多行业都喜欢搞一个大屏来展示一些统计数据，比如双十一查看全国下单金额，交管局查看各个路口的实况，书店统计畅销书，库存量等等。这次记录一下大屏项目的开发流程。 输出草图方案显示内容与格式一般来说大屏展示的内容都是一些汇总数据，展示形式包括但不限于文本，表单，图片，视频，音频，数据列表，折线图，柱状图，饼图，大地图等。 根据客户列出的内容，按模块划分，每个模块找到一种或多种适合的展示方式。 页面中还要配上一些富有 “科技感” 的元素，比如动态背景，半透明边框，折叠闪烁的折线，旋转的圆圈，不停扫描的雷达等。 展示的内容还要具有自动刷新功能，根据业务逻辑不断切换高亮内容，使整个页面一直保持 “动态”。 屏幕布局与分区使用一个草图绘制工具将模块内容依次绘制在页面中，根据模块内容的多少进行排版，一般来的大屏都是三列布局，左右显示次要内容，中间放主要内容。 如果有弹窗或其他的交互展示内容，也需要在草图上绘制出来，尽量把所有内容可视化。 绘制过程中不用过分在意细节，主要把整体样式做出来给客户去确认，细节部分在设计与编码过程中再去优化。 确定设计元素屏幕大小常见的大屏都是 1080P 或 4K 分辨率为基准，有时会有 2 联屏或 4 矩阵屏的需求，所以设计前一定要确认好最终是在什么样的屏幕上进行展示，不要做出来的网页无法适配其分辨率。 主色调根据客户的喜好与所在行业，对颜色会有不同的倾向性。一般偏科技感的大屏会选择 “深蓝” 色调的方案，而像是党建之类主旋律题材会使用 “大红” 色调。 可以找一些现成的大屏界面截图给客户做参考，从中选取主色然后搭配一些相近色做成整体配色方案。 图标图标尽量选择成套的图标库，最好是采用字体图标，方便切换与修改，这里推荐 Font Awesome, REMIX ICON。 如果是需要多色图标，可以上 Iconfont 找一下，大部分图标都支持下载 png 或 svg 格式。 动画素材这个可以一般是去素材网站上找或者自己 PS，AI 来设计。 要点就是尽量是用矢量图，在网页中也就是 SVG 格式，这样页面在适配不同分辨率或调整大小时都不会因为缩放而变糊。 实在需要用位图的就尽量用大尺寸的图片，因为是大屏项目，不需要考虑什么首屏加载时间，图片大小并不会影响使用体验。 开始编码实现模拟屏幕大屏大多都是全屏展示，所以通过 chrome 浏览器的模拟屏幕功能就可以直接设置出最终屏幕大小，方便直接查看最终效果。 Flex 布局与 REM 自适应有时候大屏会要求同时在 1080P 与 4K 设备上展示，这时候页面的自适应功能就非常重要了。 Flex 布局可以非常方便的控制行，列元素的排布，对于大部分的居中，居左，局右，水平居中，两端对齐等需求都可以很简单进行设置。 在页面中所有的宽高，字体大小都需要使用 rem 这个单位来设置，这样不同分辨率下的页面元素都会根据根节点 (html) 的字体大小去设置其大小，也就保证了整个页面元素都以 “某个大小” 为标准进行计算，从而达到了不同分辨率下一样的显示效果。 这里附上动态计算根节点字体大小的方法： 1234567891011121314151617/** * 重置页面根节点字体大小 * * 以 1080p 为基准，分割 20 份，默认文字大小 96px */function resetRootFont() { var win = window; var doc = win.document; var documentHTML = doc.documentElement; function setRootFont() { var docWidth = documentHTML.getBoundingClientRect().width; var p = docWidth / 20; documentHTML.style.fontSize = p + &quot;px&quot;; } setRootFont(); win.addEventListener(&quot;resize&quot;, setRootFont, false);} 常见依赖库图表图表库推荐 ECharts 各种常见类型图表都有。 还可以试试 DataV, 有一些 ECharts 没有的图表，并且自带一批 SVG 边框与装饰，特别适合为大屏页面添加动效。 地图地图库选择比较复杂，先要看项目是否能连接外网。 能连外网，可以直接使用 百度地图 或 腾讯地图，文档全例子多，直接根据例子改改即可。 仅限内网，如果是仅展示行政区域，可以使用 DataV地图小工具 来制作边界地图与层级地图的 JSON 文件，然后导入 ECharts 展示。如果是要能匹配百度地图那种，展示瓦片图片的，则需要购买离线地图服务部署在内网。 数据跳动countUp.js Vue2 版 Vue CountTo 动态背景Vue2 + Vue3 版 tsParticles 假数据 &amp; 真接口在真正对接数据接口前，可以在页面中直接使用 json 格式的假数据，让页面先跑起来。因为客户多多少少都会对页面有修改要求，这个调整过程就可以简单修改 json 数据来完成。 等页面全部优化完毕，所有展示内容都确定下来了，再将直接读取 json 的地方改成从后台接口返回相同格式的 json 数据即可，这样开发效率最高。 特殊情况AndroidTV 浏览器下网页展示一般来说大屏都是通过 PC 连接到屏幕，然后打开浏览器全屏展示大屏页面，所有常见的大屏都是基于桌面浏览器进行开发的。 但随着现在的智能电视越来越便宜，70-80 寸的 4K 大电视也成了大屏展示的一种设备，这类基本都内置 Android 系统，通过安装 Android TV 版的浏览器也可以进行大屏页面的展示。 需要注意的是 Android TV 版的浏览器渲染页面的分辨率并不是电视屏幕的分辨率，而是要经过设备显示比计算后的，比如 4K 电视下的显示效果分辨率远远小于 4K。 如果最终显示设备是智能电视，一定要在开发初期就在电视上实机跑一下页面，确定好渲染分辨率与模拟器中的转换比例再进行开发，避免后期出现适配问题进行返工。","link":"/posts/3058274451/"},{"title":"浏览器中 debugger 关键字","text":"使用 chrome 浏览器开发者工具查看网页源码，一直有断点干扰无法进行其他操作，然后发现了这个从未用过的 debugger 关键字。 不让查看的网页 1234(function anonymous(){22919.09999999404;debugger}) 观察下这段代码，功能就是一个立刻运行的匿名函数，里面有一个数字 + debugger 关键字。 当选择执行或跳过这个断点后，立马又被另一个结构一样只有数字不一样的方法拦住了去路，然后一直重复这个过程，让你无法使用开发者工具去查看其他内容。 可以断定，实现这个功能目的就是： 希望通过不断在页面中生成一个又一个匿名函数来打消那些企图查看页面源码的人。 debugger 关键字debugger 是 js 中的一个保留字，不过很少出现在正常的编码中。 它的做用就是调用 任何可用的调试功能，而当运行环境没有调试功能时则不起任何做用。 所以上面的页面在正常访问时，debugger 这个关键字被跳过了，被当做其不存在继续下面的流程。但如果你打开了开发者工具，运行环境有了 调试功能， 这个关键字就起作用了，跟在页面中打了断点一样，被停在那里等待你的操作。 所以这个关键字相当于一个 强制断点，一定会暂停在那里。 如何让其失效一键关闭调试在开发者工具中，右上角的按钮可以关闭调试功能，这样所有的 debugger 关键字或自己打的断点都会失效，被直接跳过。 但这样的坏处也是其他你想查看的断点也一并被跳过了。 当前行不再暂停可以找到有 debugger 这行的代码，右键选择最下面的 一律不再此处暂停 来跳过这个暂停。 不过该方法对于上面页面中不断生成新的匿名函数来说无效，总有新的代码被加载到页面中执行。 替换运行的方法如果加入 debugger 代码是在某个有名字的函数内，那么可以直接在开发者工具中新建一个同样功能但没有 debugger 关键字的函数来替换当前这个函数。 不过该方法对于上面页面中不断生成新的匿名函数来说也是无效，所以上面的代码有多么的 让人挠头 可以看出一二了。","link":"/posts/773251406/"},{"title":"阿里云更新免费SSL证书","text":"个人网站 SSL 证书过期了，更新操作流程记录下。 申请证书打开阿里云后台管理页面，找到 【数字证书管理服务】&gt; 【SSL 证书】。 无法创建证书的话，先点击【立即购买】，选择【免费证书】即可。 购买证书后点击【创建证书】，证书列表就会出现一个【待申请】证书，点击右边的【证书申请】。 填写网站域名和个人信息即可，然后就是等待审核，一般审核通过就会收到邮件通知。 回到列表页面点击【下载】，选择自己的服务器类型下载对应文件，我选的是 Nginx，下载解压后会得到两个文件。 更新证书这里以 Nginx 为例，登录服务器找到配置文件 nginx.conf 对应的目录，同级目录下创建 cert 目录，然后将下载 pem 和 key 文件放到 cert 中。 12345nginx目录 -- nginx.conf -- cert -- xxx.pem -- xxx.key 打开 nginx.conf, 在 server 下添加两行内容, 然后重启 Nginx 服务即可。 123456server { ... ssl_certificate cert/xxx.pem; ssl_certificate_key cert/xxx.key; ...} 附加：nginx 相关操作查找 nginx 配置文件1find /|grep nginx.conf 重启 nginx 服务1nginx -s reload 报错12# 错误提示nginx: [emerg] BIO_new_file(&quot;/etc/nginx/cert/pangwu86.com.pem&quot;) failed (SSL: error:02001002:system library:fopen:No such file or directory:fopen('/etc/nginx/cert/pangwu86.com.pem','r') error:2006D080:BIO routines:BIO_new_file:no such file) 查看一下 cert 目录下的文件与 nginx.conf 中配置文件名称和路径是否一致，一般是路径写错或名字不对导致找不到文件。","link":"/posts/2634616204/"},{"title":"homebrew 基本使用指南","text":"Homebrew 就是 macOS 系统的 yum，apt，pkg，用了就离不开了。 简介Homebrew 是 macOS 上最好的包管理工具，很多 Linux 上常用的命令行工具和软件都可以通过 Homebrew 来进行快速安装。 软件组成 名称 含义 brew Homebrew 源代码仓库 homebrew-core Homebrew 核心软件仓库 homebrew-bottles Homebrew 预编译二进制软件包 homebrew-cask 提供 macOS 应用和大型二进制文件 概念解释 名称 含义 formula 安装包的描述文件 cellar 安装软件的目录 /usr/local/Cellar rack 安装软件多个版本的目录 /usr/local/Cellar/foo keg 某个包的所在具体目录 /usr/local/Cellar/foo/0.1 bottle 预先编译好的包，无需下载源码编译 tap 下载源，通常使用 Git repository cask 安装 macOS native 应用的扩展 Caskroom 安装 cask 软件的目录 /usr/local/Caskroom bundle 描述 Homebrew 依赖的扩展 安装macOS 系统需要先执行安装命令行工具： 1xcode-select —install 安装脚本： 1/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 国内安装因为一些已知的网络原因，有时需要使用国内镜像源进行安装，这里推荐一个库 HomebrewCN 或者直接使用它提供的安装脚本： 1/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; 使用国内源清华大学镜像 https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/ 链接中有详细的使用介绍。 简单配置的话，就是把下面的内容加到 .bash_profile (新版 macOS 默认使用 zsh，配置文件为 .zshrc) 中即可。 12345export HOMEBREW_INSTALL_FROM_API=1export HOMEBREW_API_DOMAIN=&quot;https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/api&quot;export HOMEBREW_BOTTLE_DOMAIN=&quot;https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&quot;export HOMEBREW_BREW_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git&quot;export HOMEBREW_CORE_GIT_REMOTE=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git&quot; 常用操作Homebrew 默认把软件安装到 /usr/local/Cellar，然后通过软链链接到 /usr/local/bin。 安装brew install [软件名] 搜索brew search [软件名] 查看包信息brew info [软件名] 查看本地已安装brew list 清理旧版本brew cleanup 查看可更新brew outdated 更新软件brew upgrade 更新 homebrewbrew update 检查 homebrew 环境brew doctor 管理后台软件类似 Nginx，MySQL，MongoDB，Redis 这类服务器端软件，一般需要在后台长期运行，使用 brew services 命令可以管理这些软件。 查看服务brew services list 单次运行某个服务brew services run [服务名] 运行某个服务brew services start [服务名] 停止某个服务brew services stop [服务名] 重启某个服务brew services restart [服务名] Tap 命令homebrew 支持使用 tap 命令来扩展安装软件的来源，输入 brew tap [user/repo] 即可完成扩展。 直接输入 brew tap 可以查看当前系统下已添加的软件源。删除已添加的扩展使用 brew untap [user/repo]。 12345&gt; brew taphomebrew/cask-fontshomebrew/corehomebrew/servicesmongodb/brew 安装图形化应用早期版本需要添加扩展再使用 1brew tap caskroom/cask Caskroom 目前已经成为 homebrew 内置的一部分，命令也从过去的 brew cask xxxx 变成了 brew xxx --cask。 使用 brew search 搜索软件时会同时给出 Formulae 与 Casks 下的结果。 安装字体123456# 添加源brew tap homebrew/cask-fonts# 安装字体brew install font-jetbrains-monobrew install font-ubuntu-mono 搜索字体可以打开网址 https://github.com/Homebrew/homebrew-cask-fonts/tree/master/Casks, Ctrl + f 在网页中搜索字体名称，如果发现有 xxx.rb 文件就说明该字体可以安装，然后执行 brew install xxx 即可。 问题处理brew services 报错M1 的机器，在某次升级 homebrew 后出现了执行 services 命令报错，无法使用。 1234&gt; brew servicesError: uninitialized constant Homebrew::Service::System/opt/homebrew/Library/Taps/homebrew/homebrew-services/cmd/services.rb:58:in `services'/opt/homebrew/Library/Homebrew/brew.rb:94:in `&lt;main&gt;' 解决方法： 123456# 删除 services 指令相关服务cd /opt/homebrew/Library/Taps/homebrewrm -rf homebrew-services# 更新 homebrew-servicesbrew tap homebrew/services 安装后 brew 找不到命令首先需要将 homebrew 路径加入环境变量 PATH 中 1PATH=&quot;/usr/local/bin:$PATH&quot; 如果是新版 macOS 或 M1 机器，还需要最后添加一句 1eval $(/opt/homebrew/bin/brew shellenv)","link":"/posts/1667642005/"},{"title":"网络爬虫基础知识","text":"工欲善其事必先利其器，多了解一些基础知识，才能更好的知道从哪里下手。 HTTP 基本原理资源定位URI（Uniform Resource Identifier）即 统一资源标志符URL（Uniform Resource Locator）即 统一资源定位符URN（Uniform Resource Name）即 统一资源名称 URI 可被视为定位符（URL），名称（URN）或两者兼备。 统一资源名（URN）如同一个人的名称，而统一资源定位符（URL）代表一个人的住址。换言之，URN 定义某事物的身份，而 URL 提供查找该事物的方法。 更多信息查看 维基百科链接 超文本通过浏览器访问的网站就是使用 超文本标记语言（HyperText Markup Language，简称 HTML）编写的，除了展示页面元素还会有一些网络链接。 更多信息查看 维基百科链接 访问协议一般网页地址的开头会看到 http 或 https，这就是访问资源需要的协议类型。常见的协议还包括 ftp sftp smb 等。 HTTP（HyperText Transfer Protocol）即 超文本传输协议HTTPS (HyperText Transfer Protocol Secure， 常称为 HTTP over TLS, HTTP over SSL) 即 超文本传输安全协议，主要就是在 HTTP 下面加入了 SSL 层，所有通过它传输的内容都要通过 SSL 加密。 HTTPS 的主要作用是在不安全的网络上创建一个安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的防护。 越来越多的网站与 APP 都要求使用 HTTPS，例如： 苹果要求 iOS APP 在 2017 年 1 月 1 日前全部改为 HTTPS 加密传输，否在 APP 将无法在应用商店上架。 谷歌的 Chrome 浏览器，对未使用 HTTPS 加密的网址链接亮出风险提示，告知用户 “此网页不安全” 微信小程序要求与后台的通讯必须使用 HTTPS，不满足条件的域名与协议无法进行通信 更多信息查看 Title HTTP 请求访问一个网站的过程就是在本地浏览器中输入一个地址，浏览器发起了一个请求（Request）到服务器，服务器对其请求内容做出处理后返回一个响应（Response）,浏览器收到响应后显示对应的内容。 常见请求方法： 方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单/上传文件）。通常导致在服务器上的状态变化或副作用。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。 9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 常见响应状态码与分类： 200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 Web 网页基础网页由三部分组成，HTML，CSS，JavaScript。 HTML 相当于房屋主体框架CSS 相当于房屋的装修JavaScript 相当于房屋各种开关与电器 一般网页的标准结构： html 标签内嵌套 head 和 body 标签 head 内定义网页的配置与引用 body 内定义网页的正文内容 在 HTML 中，所有的标签定义的内容都是节点，它们构成了一个 HTML DOM 树。DOM（Document Object Model）即 文档对象模型，是 web 上构成文档结构和内容的对象的数据表示， 对访问/修改 HTML 的内容提供了接口。 爬虫基本原理爬虫就是获取网页并提取和保存信息的自动化程序。 爬虫运行的 2 个主要步骤： 构造一个请求并发送给服务器 接受到响应并将其解析出来 Session Cookies 与 TokenHTTP 是无状态的，后续如果需要处理前面的信息，需要额外传递一些内容。 在服务端，Session 保存用户信息。在客户端，Cookies 保存用户信息。二者共同协作，用来跟踪会话，确保用户访问的有效性。 大多数的应用都是用 Cookie 实现 Session 跟踪的。第一次创建 Session 时，服务端会通过在 HTTP 协议中返回给客户端，在 Cookie 中记录 SessionID，后续请求时传递 SessionID 给服务，以便后续每次请求时都可分辨你是谁。 Session 单机模式下比较适用，如果遇到大并发场景需要服务器集群，就涉及到多个服务器间的 Session 共享问题，或者在多个服务器后面放一个 Redis 来存放 Session。 Token 模式解决了集群共享 Session 的问题，它由一套固定的算法将用户信息与校验信息生成一串特殊的字符，只要签名算法不泄露变可以通过每次请求携带 Token 来判断用户的有效性。 Token 一旦生成无法让其失效，必须等到其过期才行。 Token 一般放在 header 字段中传递。 Token 比较容易做单点登录，跨域跨服务器都很容易校验。","link":"/posts/3319610330/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"IoT","slug":"IoT","link":"/tags/IoT/"},{"name":"床图","slug":"床图","link":"/tags/%E5%BA%8A%E5%9B%BE/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"钢琴","slug":"钢琴","link":"/tags/%E9%92%A2%E7%90%B4/"},{"name":"日亚","slug":"日亚","link":"/tags/%E6%97%A5%E4%BA%9A/"},{"name":"海淘","slug":"海淘","link":"/tags/%E6%B5%B7%E6%B7%98/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"基金","slug":"基金","link":"/tags/%E5%9F%BA%E9%87%91/"},{"name":"股票","slug":"股票","link":"/tags/%E8%82%A1%E7%A5%A8/"},{"name":"Vuetify","slug":"Vuetify","link":"/tags/Vuetify/"},{"name":"Vue-i18n","slug":"Vue-i18n","link":"/tags/Vue-i18n/"},{"name":"i18n","slug":"i18n","link":"/tags/i18n/"},{"name":"国际化","slug":"国际化","link":"/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"},{"name":"云服务","slug":"云服务","link":"/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"NPM","slug":"NPM","link":"/tags/NPM/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Bash","slug":"Bash","link":"/tags/Bash/"},{"name":"物联网","slug":"物联网","link":"/tags/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"芯片","slug":"芯片","link":"/tags/%E8%8A%AF%E7%89%87/"},{"name":"图床","slug":"图床","link":"/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Flask","slug":"Flask","link":"/tags/Flask/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Html","slug":"Html","link":"/tags/Html/"},{"name":"大屏","slug":"大屏","link":"/tags/%E5%A4%A7%E5%B1%8F/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"},{"name":"阿里云","slug":"阿里云","link":"/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"Web Scraper","slug":"Web-Scraper","link":"/tags/Web-Scraper/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"}],"categories":[{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Web","slug":"技术/Web","link":"/categories/%E6%8A%80%E6%9C%AF/Web/"},{"name":"经验","slug":"经验","link":"/categories/%E7%BB%8F%E9%AA%8C/"},{"name":"买买买","slug":"经验/买买买","link":"/categories/%E7%BB%8F%E9%AA%8C/%E4%B9%B0%E4%B9%B0%E4%B9%B0/"},{"name":"Vue","slug":"技术/Vue","link":"/categories/%E6%8A%80%E6%9C%AF/Vue/"},{"name":"物联网","slug":"技术/物联网","link":"/categories/%E6%8A%80%E6%9C%AF/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"网站","slug":"技术/网站","link":"/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%AB%99/"},{"name":"Git","slug":"技术/Git","link":"/categories/%E6%8A%80%E6%9C%AF/Git/"},{"name":"投资","slug":"经验/投资","link":"/categories/%E7%BB%8F%E9%AA%8C/%E6%8A%95%E8%B5%84/"},{"name":"Linux","slug":"技术/Linux","link":"/categories/%E6%8A%80%E6%9C%AF/Linux/"},{"name":"Node","slug":"技术/Node","link":"/categories/%E6%8A%80%E6%9C%AF/Node/"},{"name":"Hexo","slug":"技术/Hexo","link":"/categories/%E6%8A%80%E6%9C%AF/Hexo/"},{"name":"Python","slug":"技术/Python","link":"/categories/%E6%8A%80%E6%9C%AF/Python/"},{"name":"macOS","slug":"技术/macOS","link":"/categories/%E6%8A%80%E6%9C%AF/macOS/"}],"pages":[{"title":"关于我","text":"hi，你好 我是胖五。 这个Blog主要是记录一些个人见闻与思考，以及为自己创作的内容留个记录。 目前以程序员的身份谋生，正在努力尝试新方向，暂时就这些，以后再补充吧。 最后送上一张我每日工位的照片，希望以后这里可以多多产出好东西。","link":"/about/index.html"}]}